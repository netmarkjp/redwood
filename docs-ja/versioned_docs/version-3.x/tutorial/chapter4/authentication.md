# Authentication

## An Admin Section

<!--
Having the admin screens at `/admin` is a reasonable thing to do. Let's update the routes to make that happen by updating the four routes where the URL begins with `/posts` to start with `/admin/posts` instead:
-->

管理画面を `/admin` に置くことは、合理的なことです。これを実現するために、URLが `/posts` で始まる4つのルートを更新し、代わりに `/admin/posts` で始まるようにしましょう：

<Tabs groupId="js-ts">
<TabItem value="js" label="JavaScript">

```jsx title="web/src/Routes.js"
import { Router, Route, Set } from '@redwoodjs/router'
import ScaffoldLayout from 'src/layouts/ScaffoldLayout'
import BlogLayout from 'src/layouts/BlogLayout'

const Routes = () => {
  return (
    <Router>
      <Set wrap={ScaffoldLayout} title="Posts" titleTo="posts" buttonLabel="New Post" buttonTo="newPost">
        // highlight-start
        <Route path="/admin/posts/new" page={PostNewPostPage} name="newPost" />
        <Route path="/admin/posts/{id:Int}/edit" page={PostEditPostPage} name="editPost" />
        <Route path="/admin/posts/{id:Int}" page={PostPostPage} name="post" />
        <Route path="/admin/posts" page={PostPostsPage} name="posts" />
        // highlight-end
      </Set>
      <Set wrap={BlogLayout}>
        <Route path="/article/{id:Int}" page={ArticlePage} name="article" />
        <Route path="/contact" page={ContactPage} name="contact" />
        <Route path="/about" page={AboutPage} name="about" />
        <Route path="/" page={HomePage} name="home" />
      </Set>
      <Route notfound page={NotFoundPage} />
    </Router>
  )
}

export default Routes
```

</TabItem>
<TabItem value="ts" label="TypeScript">

```jsx title="web/src/Routes.tsx"
import { Router, Route, Set } from '@redwoodjs/router'
import ScaffoldLayout from 'src/layouts/ScaffoldLayout'
import BlogLayout from 'src/layouts/BlogLayout'

const Routes = () => {
  return (
    <Router>
      <Set wrap={ScaffoldLayout} title="Posts" titleTo="posts" buttonLabel="New Post" buttonTo="newPost">
        // highlight-start
        <Route path="/admin/posts/new" page={PostNewPostPage} name="newPost" />
        <Route path="/admin/posts/{id:Int}/edit" page={PostEditPostPage} name="editPost" />
        <Route path="/admin/posts/{id:Int}" page={PostPostPage} name="post" />
        <Route path="/admin/posts" page={PostPostsPage} name="posts" />
        // highlight-end
      </Set>
      <Set wrap={BlogLayout}>
        <Route path="/article/{id:Int}" page={ArticlePage} name="article" />
        <Route path="/contact" page={ContactPage} name="contact" />
        <Route path="/about" page={AboutPage} name="about" />
        <Route path="/" page={HomePage} name="home" />
      </Set>
      <Route notfound page={NotFoundPage} />
    </Router>
  )
}

export default Routes
```

</TabItem>
</Tabs>

<!--
Head to [http://localhost:8910/admin/posts](http://localhost:8910/admin/posts) and our generated scaffold page should come up. Thanks to named routes we don't have to update any of the `<Link>`s that were generated by the scaffolds since the `name`s of the pages didn't change!
-->

ブラウザで [http://localhost:8910/admin/posts](http://localhost:8910/admin/posts) を開くと、生成された scaffold ページ表示されるはずです。名前付きルートのおかげでページの `name` は変更されなかったので、scaffold によって生成された `<Link>` を更新する必要はありません！

<!--
Having the admin at a different path is great, but nothing is stopping someone from just browsing to that new path and messing with our blog posts. How do we keep prying eyes away?
-->

管理者が別のパスにいることは素晴らしいことですが、誰かがその新しいパスをブラウズして、私たちのブログ記事をいじくることを止めるものは何もないのです。どうすれば、覗き見されないようにできるでしょうか？

## Authentication

<!--
"Authentication" is a blanket term for all of the stuff that goes into making sure that a user, often identified with an email address and password, is allowed to access something. Authentication can be [famously fickle](https://www.rdegges.com/2017/authentication-still-sucks/) to do right both from a technical and developer-happiness standpoint.
-->

"Authentication（認証）" とは、ユーザ（しばしばメールアドレスとパスワードで識別される）が、何かにアクセスすることを許可するための包括的な用語です。認証は、技術的観点からも開発者の幸福の観点からも、正しく行うことが [famously fickle](https://www.rdegges.com/2017/authentication-still-sucks/) （継続的な実現が非常に難しいことで有名）であることがよくあります。

<!--
"Credentials" are the pieces of information a user provides to prove they are who they say they are: commonly a username (usually email) and password.
-->

"Credentials" （クレデンシャル）とは、ユーザが自分自身を証明するために提供する情報のことです：一般的にはユーザ名（だいたいはメールアドレス）とパスワードがこれにあたります。

<!--
Redwood includes two authentication paths out of the box:

* Self-hosted, where user credentials are stored in your own database
* Third-party hosted, where user credentials are stored with the third party
-->

Redwoodには2つの認証方法があります：

* セルフホスト：ユーザ認証情報はユーザ自身のデータベースに保存される
* サードパーティホスト：ユーザ認証情報はサードパーティに保存される

<!--
In both cases you end up with an authenticated user that you can access in both the web and api sides of your app.
-->

どちらの場合も、最終的にはWebサイドとAPIサイドの両方でアクセスできる認証済みユーザを得ることができます。

<!--
Redwood includes [integrations](../../authentication.md) for several of the most popular third-party auth providers:
-->

Redwood には、最も人気のあるいくつかのサードパーティの認証プロバイダの [integrations](../../authentication.md) が含まれています：

- [Auth0](https://auth0.com/)
- [Clerk](https://clerk.dev/)
- [Netlify Identity](https://docs.netlify.com/visitor-access/identity/)
- [Netlify GoTrue-JS](https://github.com/netlify/gotrue-js)
- [Magic](https://magic.link)
- [Nhost](https://nhost.io)
- [Firebase's GoogleAuthProvider](https://firebase.google.com/docs/reference/js/firebase.auth.GoogleAuthProvider)
- [Supabase](https://supabase.io/docs/guides/auth)
- [SuperTokens](https://supertokens.com)
- [WalletConnect](https://github.com/oneclickdapp/ethereum-auth)

<!--
As for our blog, we're going to use self-hosted authentication (named *dbAuth* in Redwood) since it's the simplest to get started with and doesn't involve any third party signups.
-->

このチュートリアルのブログでは、セルフホストの認証（Redwoodでは *dbAuth* という名前）を使用することにします。これは最も簡単で、サードパーティの認証サービスへのユーザ登録が不要だからです。

:::info Authentication vs. Authorization

<!--
There are two terms which contain a lot of letters, starting with an "A" and ending in "ation" (which means you could rhyme them if you wanted to) that become involved in most discussions about login:
-->

ログインを語る上で必ずと言っていいほど登場する、"A "で始まり "ation "で終わる、文字数の多い2つの用語があります（つまり、韻を踏もうと思えば踏めるということです）：

* Authentication
* Authorization

<!--
Here is how Redwood uses these terms:

* **Authentication** deals with determining whether someone is who they say they are, generally by "logging in" with an email and password, or a third party provider like Auth0.
* **Authorization** is whether a user (who has usually already been authenticated) is allowed to do something they want to do. This generally involves some combination of roles and permission checking before allowing access to a URL or feature of your site.
-->

Redwoodはこれらの用語を以下のように使用しています：

* **Authentication** （認証）は、一般的にメールアドレスとパスワード、またはAuth0のようなサードパーティプロバイダで "logging in" することによって、誰かがその人であるかどうかを決定することを扱う
* **Authorization** （認可）は、ユーザ（通常、すでに認証されている）が、彼らがしたい何かをすることを許可されているかどうか。一般的に、URLやサイト機能へのアクセスを許可する前に、ロールと権限チェックを組み合わせて判定する

<!--
This section of the tutorial focuses on **Authentication** only. See [chapter 7 of the tutorial](../chapter7/rbac.md) to learn about Authorization in Redwood.
-->

チュートリアルのこのセクションでは **Authentication** （認証）のみに焦点を当てています。Redwood の Authorization については [チュートリアルの 7 章](../chapter7/rbac.md) を参照してください。

:::

## Auth Setup

<!--
As you probably have guessed, Redwood has a couple of generators to get you going. One installs the backend components needed for dbAuth, the other creates login, signup and forgot password pages.
-->

おそらくお分かりのように、Redwood にはいくつかのジェネレータがあります。一つは dbAuth に必要なバックエンドコンポーネントをインストールするもので、もう一つはログイン、サインアップ、パスワード忘れのページを作成するものです。

<!--
Run this setup command to get the internals of dbAuth added to our app:
-->

このセットアップコマンドを実行すると、アプリに dbAuth が追加されます：

```bash
yarn rw setup auth dbAuth
```

<!--
When asked if you want to override the existing file `/api/src/lib/auth.{js,ts}` say yes. The shell `auth.{js,ts}` that's created in a new app makes sure things like the `@requireAuth` directive work, but now we'll replace it with a real implementation. When prompted to "Enable WebAuthn support", pick no - this is a separate piece of functionality we won't need for the tutorial.
-->

既存のファイル `/api/src/lib/auth.{js,ts}` を上書きするかどうか尋ねられたら "yes" と答えてください。新しいアプリに作成されるシェル `auth.{js,ts}` は `@requireAuth` ディレクティブのようなものを動作するようにしますが、今度はこれを実際の実装に置き換えることにします。 "Enable WebAuthn support" と聞かれたら、"no" を選びます - これはこのチュートリアルでは必要ない別の機能です。

<!--
You'll see that the process creates several files and includes some post-install instructions for the last couple of customizations you'll need to make. Let's go through them now.
-->

このプロセスでは、いくつかのファイルが作成され、最後に必要なカスタマイズのためのインストール後の説明も含まれていることがわかります。では、それらを見ていきましょう。

### Create a User Model

<!--
First we'll need to add a couple of fields to our `User` model. We don't even have a `User` model yet, so we'll create one along with the required fields at the same time.
-->

まず `User` モデルにいくつかのフィールドを追加する必要があります。まだ `User` モデルがないので、必要なフィールドと一緒に作成します。

<!--
Open up `schema.prisma` and add:
-->

`schema.prisma` を開いて追加します：

```javascript title="api/db/schema.prisma"
datasource db {
  provider = "sqlite"
  url      = env("DATABASE_URL")
}

generator client {
  provider      = "prisma-client-js"
  binaryTargets = "native"
}

model Post {
  id        Int      @id @default(autoincrement())
  title     String
  body      String
  createdAt DateTime @default(now())
}

model Contact {
  id        Int @id @default(autoincrement())
  name      String
  email     String
  message   String
  createdAt DateTime @default(now())
}

// highlight-start
model User {
  id                  Int       @id @default(autoincrement())
  name                String?
  email               String    @unique
  hashedPassword      String
  salt                String
  resetToken          String?
  resetTokenExpiresAt DateTime?
}
// highlight-end
```

<!--
This gives us a user with a name and email, as well as four fields that dbAuth will control:

* **hashedPassword**: stores the result of combining the user's password with a `salt` and then [hashed](https://searchsqlserver.techtarget.com/definition/hashing)
* **salt**: a unique string that combines with the hashedPassword to prevent [rainbow table attacks](https://dev.to/salothom/rainbow-tables-why-to-add-salt-45l9)
* **resetToken**: if the user forgets their password, dbAuth inserts a token in here that must be present when the user returns to reset their password
* **resetTokenExpiresAt**: a timestamp after which the `resetToken` will be considered expired and no longer valid (the user will need to fill out the forgot password form again)
-->

これにより、名前とメールアドレス持つユーザと、dbAuthが制御する4つのフィールドが得られます：

* **hashedPassword** ： ユーザのパスワードを `salt` と組み合わせて [ハッシュ化](https://searchsqlserver.techtarget.com/definition/hashing) した結果
* **salt** ： [レインボーテーブル攻撃](https://dev.to/salothom/rainbow-tables-why-to-add-salt-45l9)を防ぐためにhashedPasswordと結合されるユニークな文字列
* **resetToken** ： ユーザがパスワードを忘れた場合、dbAuthはここにトークンを挿入するので、ユーザがパスワードをリセットするために戻ってきたときここにデータ存在しなければならない
* **resetTokenExpiresAt**　： `resetToken` が期限切れで無効になるタイムスタンプ （ユーザはパスワード忘れフォームに再度記入する必要がある）

<!--
Let's create the user model by migrating the database, naming it something like "create user":
-->

データベースに"create user" のような名前をつけたマイグレーションを実行して、 ユーザモデルを作ってみましょう：

```bash
yarn rw prisma migrate dev
```

<!--
That's it for the database setup!
-->

データベースの設定は以上です！

## Private Routes

<!--
Try reloading the Posts admin and we'll see something that's 50% correct:
-->

ブログ記事管理画面を再読み込みしてみれば、50％正しいものが表示されるはずです：

![image](https://user-images.githubusercontent.com/300/146462761-d21c93f0-289a-4e11-bccf-8e4e68f21438.png)

<!--
Going to the admin section now prevents a non-logged in user from seeing posts, great! This is the result of the `@requireAuth` directive in `api/src/graphql/posts.sdl.{js,ts}`: you're not authenticated so GraphQL will not respond to your request for data. But, ideally they wouldn't be able to see the admin pages themselves. Let's fix that with a new component in the Routes file, `<Private>`:
-->

adminセクションに行くと、ログインしていないユーザがブログ記事を見ることができなくなりました。素晴らしい！これは `api/src/graphql/posts.sdl.{js,ts}` にある `@requireAuth` ディレクティブの結果です：あなたは認証されていないので、GraphQLはあなたのデータ要求に応答しません。しかし、理想を言えば、管理ページそのものを見えないようにしたいところです。Routesファイルにある新しいコンポーネント `<Private>` でそれを解決しましょう：

<Tabs groupId="js-ts">
<TabItem value="js" label="JavaScript">

```jsx title="web/src/Routes.js"
// highlight-next-line
import { Private, Router, Route, Set } from '@redwoodjs/router'
import ScaffoldLayout from 'src/layouts/ScaffoldLayout'
import BlogLayout from 'src/layouts/BlogLayout'

const Routes = () => {
  return (
    <Router>
      // highlight-next-line
      <Private unauthenticated="home">
        <Set wrap={ScaffoldLayout} title="Posts" titleTo="posts" buttonLabel="New Post" buttonTo="newPost">
          <Route path="/admin/posts/new" page={PostNewPostPage} name="newPost" />
          <Route path="/admin/posts/{id:Int}/edit" page={PostEditPostPage} name="editPost" />
          <Route path="/admin/posts/{id:Int}" page={PostPostPage} name="post" />
          <Route path="/admin/posts" page={PostPostsPage} name="posts" />
        </Set>
      // highlight-next-line
      </Private>
      <Set wrap={BlogLayout}>
        <Route path="/article/{id:Int}" page={ArticlePage} name="article" />
        <Route path="/contact" page={ContactPage} name="contact" />
        <Route path="/about" page={AboutPage} name="about" />
        <Route path="/" page={HomePage} name="home" />
      </Set>
      <Route notfound page={NotFoundPage} />
    </Router>
  )
}

export default Routes
```

</TabItem>
<TabItem value="ts" label="TypeScript">

```jsx title="web/src/Routes.tsx"
// highlight-next-line
import { Private, Router, Route, Set } from '@redwoodjs/router'
import ScaffoldLayout from 'src/layouts/ScaffoldLayout'
import BlogLayout from 'src/layouts/BlogLayout'

const Routes = () => {
  return (
    <Router>
      // highlight-next-line
      <Private unauthenticated="home">
        <Set wrap={ScaffoldLayout} title="Posts" titleTo="posts" buttonLabel="New Post" buttonTo="newPost">
          <Route path="/admin/posts/new" page={PostNewPostPage} name="newPost" />
          <Route path="/admin/posts/{id:Int}/edit" page={PostEditPostPage} name="editPost" />
          <Route path="/admin/posts/{id:Int}" page={PostPostPage} name="post" />
          <Route path="/admin/posts" page={PostPostsPage} name="posts" />
        </Set>
      // highlight-next-line
      </Private>
      <Set wrap={BlogLayout}>
        <Route path="/article/{id:Int}" page={ArticlePage} name="article" />
        <Route path="/contact" page={ContactPage} name="contact" />
        <Route path="/about" page={AboutPage} name="about" />
        <Route path="/" page={HomePage} name="home" />
      </Set>
      <Route notfound page={NotFoundPage} />
    </Router>
  )
}

export default Routes
```

</TabItem>
</Tabs>

<!--
We wrap the routes we want to be private (that is, only accessible when logged in) in the `<Private>` component, and tell our app where to send them if they are unauthenticated. In this case they should go to the `home` route.
-->

プライベートなルート（ログインしているときだけアクセスできるルート）を `<Private>` コンポーネントでラップし、認証されていないルートをどこに送ればよいかをアプリに知らせます。この場合、ルートは `home` に送られます。

<!--
Try going back to [http://localhost:8910/admin/posts](http://localhost:8910/admin/posts) now and—yikes!
-->

今 [http://localhost:8910/admin/posts](http://localhost:8910/admin/posts) に戻ってみると - なんと！

![Homepage showing user does not have permission to view](https://user-images.githubusercontent.com/300/146463430-f7bc7fc9-a966-4149-9cb6-382d89d9d636.png)

<!--
Well, we couldn't get to the admin pages, but we also can't see our blog posts any more. Do you know why we're seeing the same message here that we saw in the posts admin page?
-->

さて、管理画面には行けませんでしたが、ブログ記事も見れなくなってしまいました。なぜ、ブログ記事の管理画面で見たのと同じメッセージがここで表示されているかわかりますか？

<!--
It's because the `posts` query in `posts.sdl.{js,ts}` is used by both the homepage *and* the posts admin page. Since it has the `@requireAuth` directive, it's locked down and can only be accessed when logged in. But we *do* want people that aren't logged in to be able to view the posts on the homepage!
-->

`posts.sdl.{js,ts}` の `posts` クエリが、ホームページとブログ記事管理ページの *両方で* 使用されるからです。これは `@requireAuth` ディレクティブを持つので、ログインしているときだけアクセスできるようにロックされています。しかし、ログインしていない人がホームページのブログ記事を見ることができるように *したい* のです！

<!--
Now that our admin pages are behind a `<Private>` route, what if we set the `posts` query to be `@skipAuth` instead? Let's try:
-->

管理ページが `<Private>` ルートの配下になったので、代わりに `posts` クエリを `@skipAuth` に設定したらどうでしょうか。試してみましょう：

<Tabs groupId="js-ts">
<TabItem value="js" label="JavaScript">

```graphql title="api/src/graphql/posts.sdl.js"
export const schema = gql`
  type Post {
    id: Int!
    title: String!
    body: String!
    createdAt: DateTime!
  }

  type Query {
    // highlight-next-line
    posts: [Post!]! @skipAuth
    post(id: Int!): Post @requireAuth
  }

  input CreatePostInput {
    title: String!
    body: String!
  }

  input UpdatePostInput {
    title: String
    body: String
  }

  type Mutation {
    createPost(input: CreatePostInput!): Post! @requireAuth
    updatePost(id: Int!, input: UpdatePostInput!): Post! @requireAuth
    deletePost(id: Int!): Post! @requireAuth
  }
`
```

</TabItem>
<TabItem value="ts" label="TypeScript">

```graphql title="api/src/graphql/posts.sdl.ts"
export const schema = gql`
  type Post {
    id: Int!
    title: String!
    body: String!
    createdAt: DateTime!
  }

  type Query {
    // highlight-next-line
    posts: [Post!]! @skipAuth
    post(id: Int!): Post @requireAuth
  }

  input CreatePostInput {
    title: String!
    body: String!
  }

  input UpdatePostInput {
    title: String
    body: String
  }

  type Mutation {
    createPost(input: CreatePostInput!): Post! @requireAuth
    updatePost(id: Int!, input: UpdatePostInput!): Post! @requireAuth
    deletePost(id: Int!): Post! @requireAuth
  }
`
```

</TabItem>
</Tabs>

<!--
Reload the homepage and:
-->

ホームページを再読み込みすると：

![image](https://user-images.githubusercontent.com/300/146463788-7ab8afbb-8cd8-4c16-b8d2-02a00bcd7b46.png)

<!--
They're back! Let's just check that if we click on one of our posts that we can see it...UGH:
-->

戻ってきました！一応それぞれのブログ記事が見られるかもチェックしてみましょう...ぐぬぬ：

![image](https://user-images.githubusercontent.com/300/146463841-cb9c95b6-3cc8-4697-9056-97fdebb49c51.png)

<!--
This page shows a single post, using the `post` query, not `posts`! So, we need to `@skipAuth` on that one as well:
-->

このページでは単一のブログ記事を表示するのに `posts` ではなく `post` クエリを使っています！そのためこちらにも `@skipAuth` が必要です：

<Tabs groupId="js-ts">
<TabItem value="js" label="JavaScript">

```graphql title="api/src/graphql/posts.sdl.js"
export const schema = gql`
  type Post {
    id: Int!
    title: String!
    body: String!
    createdAt: DateTime!
  }

  type Query {
    posts: [Post!]! @skipAuth
    // highlight-next-line
    post(id: Int!): Post @skipAuth
  }

  input CreatePostInput {
    title: String!
    body: String!
  }

  input UpdatePostInput {
    title: String
    body: String
  }

  type Mutation {
    createPost(input: CreatePostInput!): Post! @requireAuth
    updatePost(id: Int!, input: UpdatePostInput!): Post! @requireAuth
    deletePost(id: Int!): Post! @requireAuth
  }
`
```

</TabItem>
<TabItem value="ts" label="TypeScript">

```graphql title="api/src/graphql/posts.sdl.ts"
export const schema = gql`
  type Post {
    id: Int!
    title: String!
    body: String!
    createdAt: DateTime!
  }

  type Query {
    posts: [Post!]! @skipAuth
    // highlight-next-line
    post(id: Int!): Post @skipAuth
  }

  input CreatePostInput {
    title: String!
    body: String!
  }

  input UpdatePostInput {
    title: String
    body: String
  }

  type Mutation {
    createPost(input: CreatePostInput!): Post! @requireAuth
    updatePost(id: Int!, input: UpdatePostInput!): Post! @requireAuth
    deletePost(id: Int!): Post! @requireAuth
  }
`
```

</TabItem>
</Tabs>

<!--
Cross your fingers and reload!
-->

指をくわえてリロード！

![image](https://user-images.githubusercontent.com/300/146463959-c59c8721-484f-45de-a663-e6ab3b2591dc.png)

<!--
We're back in business! Once you add authentication into your app you'll probably run into several situations like this where you need to go back and forth, re-allowing access to some pages or queries that inadvertently got locked down by default. Remember, Redwood is secure by default—we'd rather you accidentally expose too *little* of your app than too *much*!
-->

やったね！アプリに認証を追加すると、このように、デフォルトでロックされているページやクエリへのアクセスを再許可しなければならない状況に何度か遭遇するでしょう。Redwoodはデフォルトでセキュアであることを忘れないでください -- アプリの意図しない公開は *多い* より *少ない* ほうがいいでしょう！

<!--
Now that our pages are behind login, let's actually create a login page so that we can see them again.
-->

さて、ページがログイン後にあるため、実際にログインページを作成して、再び見ることができるようにしましょう。

:::info Skipping auth altogether for `posts` and `post` feels bad somehow...

<!--
Ahh, good eye. While posts don't currently expose any particularly secret information, what if we eventually add a field like `publishStatus` where you could mark a post as `draft` so that it doesn't show on the homepage. But, if you knew enough about GraphQL, you could easily request all posts in the database and be able to read all the drafts!
-->

ああ、良い目の付け所ですね。ブログ記事は今のところ特に秘密の情報を公開しませんが、いずれ `publishStatus` のようなフィールドを追加して、ブログ記事を `draft` （下書き）としてマークし、ホームページには表示されないようにしたらどうでしょう。しかし、もしあなたがGraphQLについて十分に知っていれば、データベース内のすべてのブログ記事を簡単にリクエストでき、すべての下書きを読むことができるようになります！

<!--
It would be more future-proof to create a *new* endpoint for public display of posts, something like `publicPosts` and `publicPost` that will have built-in logic to only ever return a minimal amount of data and leave the default `posts` and `post` queries returning all the data for a post, something that only the admin will have access to. (Or do the opposite: keep `posts` and `post` as public and create new `adminPosts` and `adminPost` endpoints that can contain sensitive information.)
-->

`publicPosts` や `publicPost` のような公開されたブログ記事を取得する *新しい* エンドポイントを作成するほうが将来有望でしょう。
その場合、新しいエンドポイントは最小限のデータしか返さないようにするためのロジックを組み込み、デフォルトの `posts` と `post` クエリはブログ記事の全データを返し管理者だけがアクセスできるようにします（逆に `posts` と `post` を public にして、機密情報を含むことができる `adminPosts` と `adminPost` というエンドポイントを新たに作成することもできます）。

:::

## Login & Signup Pages

<!--
Yet another generator is here for you, this time one that will create pages for login, signup and forgot password pages:
-->

今回は、ログイン、サインアップ、パスワード忘れなどのページを作成するもうひとつのジェネレータをご紹介します。

```bash
yarn rw g dbAuth
```

<!--
Again several pages will be created and some post-install instructions will describe next steps. But for now, try going to [http://localhost:8910/login](http://localhost:8910/login):
-->

またここでいくつかのページが作成され、インストール後の手順が説明されます。しかし、とりあえず、[http://localhost:8910/login](http://localhost:8910/login) にアクセスしてみてください：

![Generated login page](https://user-images.githubusercontent.com/300/146464693-a8fc4cf9-7fed-474f-8335-bb4c80fe0a5e.png)

<!--
That was easy! We don't have a user to login with, so try going to the signup page instead (there's a link under the Login button, or just head to [http://localhost:8910/signup](http://localhost:8910/signup)):
-->

簡単でしたね！ログインするユーザがいないので、代わりにサインアップページに行ってみてください（ログインボタンの下にリンクがあります、または [http://localhost:8910/signup](http://localhost:8910/signup) を開いてください）。

![Generated signup page](https://user-images.githubusercontent.com/300/146464785-a5996b19-27c5-493c-8fb3-1c753add31a6.png)

<!--
dbAuth defaults to the generic "Username" for the first field, but in our case the username will be an email address (we can change that label in a moment). Create yourself a user with email and password:
-->

dbAuthのデフォルトでは、最初のフィールドは一般的な "Username" ですが、私たちの場合、ユーザ名はメールアドレスになります（このラベルはすぐに変更可能です）。メールアドレスメールとパスワードでユーザを作成します：

![image](https://user-images.githubusercontent.com/300/146464870-cb859f8b-175f-4170-8da4-5286facd1fe5.png)

<!--
And after clicking "Signup" you should end up back on the homepage, where everything looks the same! Yay? But now try going to [http://localhost:8910/admin/posts](http://localhost:8910/admin/posts):
-->

そして "Signup" をクリックすると、ホームページに戻り、すべてが同じように見えるはずです！やったー？しかし、今度は [http://localhost:8910/admin/posts](http://localhost:8910/admin/posts) に行ってみてください：

![Posts admin](https://user-images.githubusercontent.com/300/146465485-c169a4b8-f398-47ec-8412-4fc15a666976.png)

<!--
Awesome! Signing up will automatically log you in (although this behavior [can be changed](../../authentication.md#signuphandler)) and if you look in the code for the `SignupPage` you'll see where the redirect to the homepage takes place (hint: check out line 21).
-->

すごい！サインアップすると自動的にログインします（この動作は [変更可能](../../authentication.md#signuphandler) ）。 `SignupPage` のコードを見れば、ホームページへのリダイレクトが行われる場所がわかります（ヒント：21行目を確認してください）。

## Add a Logout Link

<!--
Now that we're logged in, how do we log out? Let's add a link to the `BlogLayout` so that it's present on all pages, and also include an indicator of who you're actually logged in as.
-->

さて、ログインしたところで、どうやってログアウトするのでしょうか？すべてのページに表示されるように `BlogLayout` にリンクを追加し、実際に誰としてログインしているかの表示も追加しましょう。

<!--
Redwood provides a [hook](../../authentication.md#api) `useAuth` which we can use in our components to determine the state of the user's login-ness, get their user info, and more. In `BlogLayout` we want to destructure the `isAuthenticated`, `currentUser` and `logOut` properties from `useAuth()`:
-->

Redwood は [hook](../../authentication.md#api) の `useAuth` を提供しており、これをコンポーネント内で使用して、ユーザのログイン状態を判断したり、ユーザ情報を取得したりすることができます。 `BlogLayout` では、 `useAuth()` から `isAuthenticated` 、 `currentUser` 、 `logOut` プロパティを再構築したいと思います：

<Tabs groupId="js-ts">
<TabItem value="js" label="JavaScript">

```jsx title="web/src/layouts/BlogLayout/BlogLayout.js"
// highlight-next-line
import { useAuth } from '@redwoodjs/auth'
import { Link, routes } from '@redwoodjs/router'

const BlogLayout = ({ children }) => {
  // highlight-next-line
  const { isAuthenticated, currentUser, logOut } = useAuth()

  return (
    <>
      <header>
        <h1>
          <Link to={routes.home()}>Redwood Blog</Link>
        </h1>
        <nav>
          <ul>
            <li>
              <Link to={routes.home()}>Home</Link>
            </li>
            <li>
              <Link to={routes.about()}>About</Link>
            </li>
            <li>
              <Link to={routes.contact()}>Contact</Link>
            </li>
          </ul>
        </nav>
      </header>
      <main>{children}</main>
    </>
  )
}

export default BlogLayout
```

</TabItem>
<TabItem value="ts" label="TypeScript">

```jsx title="web/src/layouts/BlogLayout/BlogLayout.tsx"
// highlight-next-line
import { useAuth } from '@redwoodjs/auth'
import { Link, routes } from '@redwoodjs/router'

type BlogLayoutProps = {
  children?: React.ReactNode
}

const BlogLayout = ({ children }: BlogLayoutProps) => {
  // highlight-next-line
  const { isAuthenticated, currentUser, logOut } = useAuth()

  return (
    <>
      <header>
        <h1>
          <Link to={routes.home()}>Redwood Blog</Link>
        </h1>
        <nav>
          <ul>
            <li>
              <Link to={routes.home()}>Home</Link>
            </li>
            <li>
              <Link to={routes.about()}>About</Link>
            </li>
            <li>
              <Link to={routes.contact()}>Contact</Link>
            </li>
          </ul>
        </nav>
      </header>
      <main>{children}</main>
    </>
  )
}

export default BlogLayout
```

</TabItem>
</Tabs>

<!--
As you can probably tell by the names:

* **isAuthenticated**: a boolean as to whether or not a user is logged in
* **currentUser**: any details the app has on that user (more on this in a moment)
* **logOut**: removes the user's session and logs them out
-->

たぶん名前でわかると思いますが：

* **isAuthenticated** ： ユーザがログインしているかどうかのブール値
* **currentUser** ： アプリが持つそのユーザの詳細（詳細は後述）
* **logOut** ： ユーザのセッションを削除し、ログアウトさせる

<!--
At the top right of the page, let's show the email address of the user (if they're logged in) as well as a link to log out. If they're not logged in, let's show a link to do just that:
-->

ページの右上には、ユーザのメールアドレス（ログインしている場合）とログアウトのためのリンクを表示しましょう。ログインしていない場合は、ログインのリンクを表示します：

<Tabs groupId="js-ts">
<TabItem value="js" label="JavaScript">

```jsx title="web/src/layouts/BlogLayout/BlogLayout.js"
import { useAuth } from '@redwoodjs/auth'
import { Link, routes } from '@redwoodjs/router'

const BlogLayout = ({ children }) => {
  const { isAuthenticated, currentUser, logOut } = useAuth()

  return (
    <>
      <header>
        // highlight-next-line
        <div className="flex-between">
          <h1>
            <Link to={routes.home()}>Redwood Blog</Link>
          </h1>
          // highlight-start
          {isAuthenticated ? (
            <div>
              <span>Logged in as {currentUser.email}</span>{' '}
              <button type="button" onClick={logOut}>
                Logout
              </button>
            </div>
          ) : (
            <Link to={routes.login()}>Login</Link>
          )}
        </div>
        // highlight-end
        <nav>
          <ul>
            <li>
              <Link to={routes.home()}>Home</Link>
            </li>
            <li>
              <Link to={routes.about()}>About</Link>
            </li>
            <li>
              <Link to={routes.contact()}>Contact</Link>
            </li>
          </ul>
        </nav>
      </header>
      <main>{children}</main>
    </>
  )
}

export default BlogLayout
```

</TabItem>
<TabItem value="ts" label="TypeScript">

```jsx title="web/src/layouts/BlogLayout/BlogLayout.tsx"
import { useAuth } from '@redwoodjs/auth'
import { Link, routes } from '@redwoodjs/router'

type BlogLayoutProps = {
  children?: React.ReactNode
}

const BlogLayout = ({ children }: BlogLayoutProps) => {
  const { isAuthenticated, currentUser, logOut } = useAuth()

  return (
    <>
      <header>
        // highlight-next-line
        <div className="flex-between">
          <h1>
            <Link to={routes.home()}>Redwood Blog</Link>
          </h1>
          // highlight-start
          {isAuthenticated ? (
            <div>
              <span>Logged in as {currentUser.email}</span>{' '}
              <button type="button" onClick={logOut}>
                Logout
              </button>
            </div>
          ) : (
            <Link to={routes.login()}>Login</Link>
          )}
        </div>
        // highlight-end
        <nav>
          <ul>
            <li>
              <Link to={routes.home()}>Home</Link>
            </li>
            <li>
              <Link to={routes.about()}>About</Link>
            </li>
            <li>
              <Link to={routes.contact()}>Contact</Link>
            </li>
          </ul>
        </nav>
      </header>
      <main>{children}</main>
    </>
  )
}

export default BlogLayout
```

</TabItem>
</Tabs>

![image](https://user-images.githubusercontent.com/300/146466685-cd91d9e6-e341-4698-81a6-cc404d6b3098.png)

<!--
Well, it's almost right! Where's our email address? By default, the function that determines what's in `currentUser` only returns that user's `id` field for security reasons (better to expose too little than too much, remember!). To add email to that list, check out `api/src/lib/auth.{js,ts}`:
-->

まあ、だいたい合ってるんですけどね！メールアドレスはどこでしょ？デフォルトでは、 `currentUser` に何が入っているかを判断する関数は、セキュリティ上の理由から、そのユーザの `id` フィールドのみを返します（公開しすぎるよりは、少なすぎる方が良いことを覚えておいてください!）。そのリストにemailを追加するには、 `api/src/lib/auth.{js,ts}` をチェックしてください：

<Tabs groupId="js-ts">
<TabItem value="js" label="JavaScript">

```javascript title="api/src/lib/auth.js"
import { AuthenticationError, ForbiddenError } from '@redwoodjs/graphql-server'
import { db } from './db'

export const getCurrentUser = async (session) => {
  return await db.user.findUnique({
    where: { id: session.id },
    select: { id: true },
  })
}

export const isAuthenticated = () => {
  return !!context.currentUser
}

export const hasRole = (roles) => {
  if (!isAuthenticated()) {
    return false
  }

  const currentUserRoles = context.currentUser?.roles

  if (typeof roles === 'string') {
    if (typeof currentUserRoles === 'string') {
      // roles to check is a string, currentUser.roles is a string
      return currentUserRoles === roles
    } else if (Array.isArray(currentUserRoles)) {
      // roles to check is a string, currentUser.roles is an array
      return currentUserRoles?.some((allowedRole) => roles === allowedRole)
    }
  }

  if (Array.isArray(roles)) {
    if (Array.isArray(currentUserRoles)) {
      // roles to check is an array, currentUser.roles is an array
      return currentUserRoles?.some((allowedRole) =>
        roles.includes(allowedRole)
      )
    } else if (typeof currentUserRoles === 'string') {
      // roles to check is an array, currentUser.roles is a string
      return roles.some((allowedRole) => currentUserRoles === allowedRole)
    }
  }

  // roles not found
  return false
}

export const requireAuth = ({ roles } = {}) => {
  if (!isAuthenticated()) {
    throw new AuthenticationError("You don't have permission to do that.")
  }

  if (roles && !hasRole(roles)) {
    throw new ForbiddenError("You don't have access to do that.")
  }
}
```
</TabItem>
<TabItem value="ts" label="TypeScript">

```ts title="api/src/lib/auth.ts"
import { AuthenticationError, ForbiddenError } from '@redwoodjs/graphql-server'
import { db } from './db'

import type { DbAuthSession } from '@redwoodjs/api'

export const getCurrentUser = async (session: DbAuthSession<number>) => {
  return await db.user.findUnique({
    where: { id: session.id },
    select: { id: true },
  })
}

export const isAuthenticated = (): boolean => {
  return !!context.currentUser
}

type AllowedRoles = string | string[] | undefined

export const hasRole = (roles: AllowedRoles): boolean => {
  if (!isAuthenticated()) {
    return false
  }

  const currentUserRoles = context.currentUser?.roles

  if (typeof roles === 'string') {
    if (typeof currentUserRoles === 'string') {
      // roles to check is a string, currentUser.roles is a string
      return currentUserRoles === roles
    } else if (Array.isArray(currentUserRoles)) {
      // roles to check is a string, currentUser.roles is an array
      return currentUserRoles?.some((allowedRole) => roles === allowedRole)
    }
  }

  if (Array.isArray(roles)) {
    if (Array.isArray(currentUserRoles)) {
      // roles to check is an array, currentUser.roles is an array
      return currentUserRoles?.some((allowedRole) =>
        roles.includes(allowedRole)
      )
    } else if (typeof currentUserRoles === 'string') {
      // roles to check is an array, currentUser.roles is a string
      return roles.some((allowedRole) => currentUserRoles === allowedRole)
    }
  }

  // roles not found
  return false
}

export const requireAuth = ({ roles }: { roles?: AllowedRoles } = {}) => {
  if (!isAuthenticated()) {
    throw new AuthenticationError("You don't have permission to do that.")
  }

  if (roles && !hasRole(roles)) {
    throw new ForbiddenError("You don't have access to do that.")
  }
}
```
</TabItem>
</Tabs>

<!--
The `getCurrentUser()` function is where the magic happens: whatever is returned by this function is the content of `currentUser`, in both the web and api sides! In the case of dbAuth, the single argument passed in, `session`, contains the `id` of the user that's logged in. It then looks up the user in the database with Prisma, selecting just the `id`. Let's add `email` to this list:
-->

`getCurrentUser()` 関数は、マジックが起こる場所です：この関数が返すのは、Webサイドと APIサイドの両方で `currentUser` の内容なのです！ dbAuth の場合、唯一の引数として渡される `session` には、ログインしているユーザの `id` が含まれます。 そして、Prismaでデータベース内のユーザを検索し、 `id` だけを選択します。ここに `email` を追加してみましょう：

<Tabs groupId="js-ts">
<TabItem value="js" label="JavaScript">

```javascript title="api/src/lib/auth.js"
export const getCurrentUser = async (session) => {
  return await db.user.findUnique({
    where: { id: session.id },
    // highlight-next-line
    select: { id: true, email: true},
  })
}
```

</TabItem>
<TabItem value="ts" label="TypeScript">

```ts title="api/src/lib/auth.ts"
export const getCurrentUser = async (session) => {
  return await db.user.findUnique({
    where: { id: session.id },
    // highlight-next-line
    select: { id: true, email: true},
  })
}
```

</TabItem>
</Tabs>

<!--
Now our email should be present at the upper right on the homepage:
-->

これでメールアドレスがホームページの右上に表示されるはずです：

![image](https://user-images.githubusercontent.com/300/146467129-c0446c1a-3648-4787-9675-d66eb80b8ab6.png)

<!--
Before we leave this file, take a look at `requireAuth()`. Remember when we talked about the `@requireAuth` directive and how when we first installed authentication we saw the message "You don't have permission to do that."? This is where that came from!
-->

このファイルから離れる前に `requireAuth()` を見てみましょう。 `@requireAuth` ディレクティブの話をしたとき、最初に認証をインストールしたときに "You don't have permission to do that" というメッセージが表示されたのを覚えていますか？あのメッセージはここからきています！

## Session Secret

<!--
After the initial `setup` command, which installed dbAuth, you may have noticed that an edit was made to the `.env` file in the root of your project. The `setup` script appended a new ENV var called `SESSION_SECRET` along with a big random string of numbers and letters. This is the encryption key for the cookies that are stored in the user's browser when they log in. This secret should never be shared, never checked into your repo, and should be re-generated for each environment you deploy to.
-->

最初の `setup` コマンドで dbAuth をインストールした後、プロジェクトのルートにある `.env` ファイルが編集されたことにお気づきでしょうか。 `setup` スクリプトは `SESSION_SECRET` という新しい環境変数に、数字と文字からなるランダムな長い文字列を追加していました。これは、ユーザがログインしたときにブラウザに保存されるクッキーの暗号化キーです。この秘密は決して共有してはいけませんし、あなたのリポジトリにチェックインしてもいけません。また、デプロイする環境ごとに再作成しなければなりません。

<!--
You can generate a new value with the `yarn rw g secret` command. It only outputs it to the terminal, you'll need to copy/paste to your `.env` file. Note that if you change this secret in a production environment, all users will be logged out on their next request because the cookie they currently have cannot be decrypted with the new key! They'll need to log in again to a new cookie encrypted with the new key.
-->

新しい値は `yarn rw g secret` コマンドで生成できます。このコマンドはターミナルに出力されるだけなので、 `.env` ファイルにコピー＆ペーストする必要があります。本番環境でこのキーを変更すると、すべてのユーザが次のリクエストでログアウトしてしまうことに注意してください！なぜなら、現在持っているクッキーを新しいキーで復号することができないからです。ユーザは新しいキーで暗号化された新しいクッキーで再度ログインする必要があります。

## Wrapping Up

<!--
Believe it or not, that's pretty much it for authentication! You can use the combination of `@requireAuth` and `@skipAuth` directives to lock down access to GraphQL query/mutations, and the `<Private>` component to restrict access to entire pages of your app. If you only want to restrict access to certain components, or certain parts of a component, you can always get `isAuthenticated` from the `useAuth()` hook and then render one thing or another.
-->

信じられないかもしれませんが、これで認証はほぼ完了です！ `@requireAuth` と `@skipAuth` ディレクティブの組み合わせで GraphQL クエリ/ミューテーションへのアクセスをロックしたり、 `<Private>` コンポーネントを使用してアプリのページ全体へのアクセスを制限したりできます。特定のコンポーネント、またはコンポーネントの特定の部分へのアクセスのみを制限したい場合は、常に `useAuth()` フックから `isAuthenticated` を取得して個別にレンダリングしなければなりません。

<!--
Head over to the Redwood docs to read more about [self-hosted authentication](../../authentication.md#self-hosted-auth-installation-and-setup) and [third-party authentication](../../authentication.md#third-party-providers-installation-and-setup).
-->

Redwood のドキュメントを読み込むなら [self-hosted authentication](../../authentication.md#self-hosted-auth-installation-and-setup) と [third-party authentication](../../authentication.md#third-party-providers-installation-and-setup) をどうぞ。

## One More Thing

<!--
Remember the GraphQL Playground exercise at the end of [Creating a Contact](../chapter3/saving-data.md#creating-a-contact)? Try to run that again now that authentication is in place and you should get that error we've been talking about because of the `@requireAuth` directive! But, creating a *new* contact should still work just fine (because we're using `@skipAuth` on that mutation).
-->

[Creating a Contact](../chapter3/saving-data.md#creating-a-contact) の最後にあるGraphQL Playgroundを覚えていますか？認証が実装された今の状態でもう一度実行してみると、先ほど説明した `@requireAuth` ディレクティブが原因でエラーが発生するはずです！しかし、*新しい* お問い合わせの追加は問題なく行えるはずです（このミューテーションでは `@skipAuth` を使用しているからです）。

<!--
However, simulating a logged-in user through the GraphQL Playground is no picnic. But, we're working on improving the experience!
-->

しかしながら、GraphQL Playgroundを通じてログインしたユーザをシミュレートすることは、そう楽しいことではありません。しかし、私たちはこの体験を改善するために努力しています！
